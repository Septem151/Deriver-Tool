package com.eawf.deriver.ecc;

import java.math.BigInteger;
import java.security.spec.ECPoint;

/**
 * Slightly modified version of a solution posted by ChiaraHsieh to the
 * question:
 * <a href="https://stackoverflow.com/questions/15727147/scalar-multiplication-of-point-over-elliptic-curve">Scalar
 * Multiplication of Point over elliptic Curve</a>
 *
 * @author Carson Mullins
 */
public class ScalarMultiply {

    private ScalarMultiply() {
    } // Non-instantiable

    private static final BigInteger TWO = new BigInteger("2");

    /**
     * Performs scalar multiplication about the point P with integer kin where
     * the returned point R = P * kin (scalar multiplication).
     *
     * @param P the generator ECPoint.
     * @param kin the BigInteger to multiply point P by.
     * @return the ECPoint generated by scalar multiplication of P * kin.
     */
    public static ECPoint scalmult(ECPoint P, BigInteger kin) {
        ECPoint R = ECPoint.POINT_INFINITY, S = P;
        BigInteger k = kin.mod(CurveParams.p);
        int length = k.bitLength();
        byte[] binarray = new byte[length];
        for (int i = 0; i <= length - 1; i++) {
            binarray[i] = k.mod(TWO).byteValue();
            k = k.divide(TWO);
        }

        for (int i = length - 1; i >= 0; i--) {
            R = doublePoint(R);
            if (binarray[i] == 1) {
                R = addPoint(R, S);
            }
        }
        return R;
    }

    /**
     * Adds two ECPoints together along the EC Curve.
     *
     * @param r the first point.
     * @param s the second point.
     * @return the ECPoint where out = r + s.
     */
    public static ECPoint addPoint(ECPoint r, ECPoint s) {
        if (r.equals(s)) {
            return doublePoint(r);
        } else if (r.equals(ECPoint.POINT_INFINITY)) {
            return s;
        } else if (s.equals(ECPoint.POINT_INFINITY)) {
            return r;
        }
        BigInteger slope = (r.getAffineY().subtract(s.getAffineY()))
                .multiply(r.getAffineX().subtract(s.getAffineX())
                        .modInverse(CurveParams.p)).mod(CurveParams.p);
        BigInteger Xout = (slope.modPow(TWO, CurveParams.p)
                .subtract(r.getAffineX())).subtract(s.getAffineX()).mod(CurveParams.p);
        BigInteger Yout = s.getAffineY().negate().mod(CurveParams.p);
        Yout = Yout.add(slope.multiply(s.getAffineX().subtract(Xout))).mod(CurveParams.p);
        ECPoint out = new ECPoint(Xout, Yout);
        return out;
    }

    /**
     * Doubles an ECPoint along the EC Curve.
     *
     * @param r the Point to double.
     * @return the ECPoint where out = r + r
     */
    private static ECPoint doublePoint(ECPoint r) {
        if (r.equals(ECPoint.POINT_INFINITY)) {
            return r;
        }
        BigInteger slope = (r.getAffineX().pow(2)).multiply(new BigInteger("3"));
        slope = slope.add(CurveParams.a);
        slope = slope.multiply((r.getAffineY().multiply(TWO)).modInverse(CurveParams.p));
        BigInteger Xout = slope.pow(2).subtract(r.getAffineX().multiply(TWO)).mod(CurveParams.p);
        BigInteger Yout = (r.getAffineY().negate()).add(slope.multiply(r.getAffineX().subtract(Xout)))
                .mod(CurveParams.p);
        ECPoint out = new ECPoint(Xout, Yout);
        return out;
    }
}
